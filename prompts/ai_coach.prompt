# Icon App - AI Coach Implementation

You are a senior Flutter engineer implementing the AI coaching module for the Icon fitness app. Create comprehensive AI coaching features using OpenAI integration with voice interaction and personalized recommendations.

## Project Context

The AI coach module should provide:
- Personalized workout recommendations
- Real-time coaching during workouts
- Voice interaction (speech-to-text and text-to-speech)
- Exercise form guidance
- Progress analysis and feedback
- Motivational support
- Goal setting and tracking

## Required Implementation

### 1. AI Coach Models

Create `lib/features/ai_coach/data/models/coach_message_model.dart`:

```dart
class CoachMessageModel {
  final String id;
  final String userId;
  final String message;
  final String response;
  final String messageType; // 'user', 'coach'
  final DateTime timestamp;
  final Map<String, dynamic> context;
  final bool isProcessed;

  CoachMessageModel({
    required this.id,
    required this.userId,
    required this.message,
    required this.response,
    required this.messageType,
    required this.timestamp,
    this.context = const {},
    this.isProcessed = false,
  });

  factory CoachMessageModel.fromJson(Map<String, dynamic> json) {
    return CoachMessageModel(
      id: json['id'] as String,
      userId: json['user_id'] as String,
      message: json['message'] as String,
      response: json['response'] as String,
      messageType: json['message_type'] as String,
      timestamp: DateTime.parse(json['timestamp'] as String),
      context: json['context'] as Map<String, dynamic>? ?? {},
      isProcessed: json['is_processed'] as bool? ?? false,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'user_id': userId,
      'message': message,
      'response': response,
      'message_type': messageType,
      'timestamp': timestamp.toIso8601String(),
      'context': context,
      'is_processed': isProcessed,
    };
  }
}
```

Create `lib/features/ai_coach/data/models/coach_recommendation_model.dart`:

```dart
class CoachRecommendationModel {
  final String id;
  final String userId;
  final String type; // 'workout', 'exercise', 'nutrition', 'motivation'
  final String title;
  final String description;
  final Map<String, dynamic> data;
  final DateTime createdAt;
  final bool isRead;
  final int priority; // 1-5, higher is more important

  CoachRecommendationModel({
    required this.id,
    required this.userId,
    required this.type,
    required this.title,
    required this.description,
    required this.data,
    required this.createdAt,
    this.isRead = false,
    this.priority = 3,
  });

  factory CoachRecommendationModel.fromJson(Map<String, dynamic> json) {
    return CoachRecommendationModel(
      id: json['id'] as String,
      userId: json['user_id'] as String,
      type: json['type'] as String,
      title: json['title'] as String,
      description: json['description'] as String,
      data: json['data'] as Map<String, dynamic>,
      createdAt: DateTime.parse(json['created_at'] as String),
      isRead: json['is_read'] as bool? ?? false,
      priority: json['priority'] as int? ?? 3,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'user_id': userId,
      'type': type,
      'title': title,
      'description': description,
      'data': data,
      'created_at': createdAt.toIso8601String(),
      'is_read': isRead,
      'priority': priority,
    };
  }
}
```

### 2. AI Coach Repository

Create `lib/features/ai_coach/data/repositories/ai_coach_repository.dart`:

```dart
import '../../../../core/services/openai_service.dart';
import '../../../../core/services/voice_service.dart';
import '../../../../core/services/supabase_service.dart';
import '../models/coach_message_model.dart';
import '../models/coach_recommendation_model.dart';

class AICoachRepository {
  final OpenAIService _openAIService = OpenAIService();
  final VoiceService _voiceService = VoiceService();
  final SupabaseService _supabaseService = SupabaseService();

  /// Send message to AI coach
  Future<String> sendMessage({
    required String message,
    required Map<String, dynamic> context,
  }) async {
    try {
      // Prepare context for AI
      final aiContext = _prepareAIContext(context);
      
      // Send to OpenAI
      final response = await _openAIService.sendChatCompletion(
        messages: [
          {
            'role': 'system',
            'content': '''You are an AI fitness coach for the Icon app. You help users with:
- Workout recommendations and planning
- Exercise form guidance
- Motivation and encouragement
- Progress tracking and analysis
- Goal setting and achievement

Be supportive, knowledgeable, and concise. Provide actionable advice.''',
          },
          {
            'role': 'user',
            'content': 'Context: $aiContext\n\nUser message: $message',
          },
        ],
        temperature: 0.7,
        maxTokens: 500,
      );

      // Save conversation to database
      await _saveConversation(message, response, context);

      return response;
    } catch (e) {
      throw Exception('Failed to get AI response: $e');
    }
  }

  /// Generate workout recommendation
  Future<CoachRecommendationModel> generateWorkoutRecommendation({
    required String userId,
    required Map<String, dynamic> userProfile,
    required List<Map<String, dynamic>> recentWorkouts,
  }) async {
    try {
      final context = {
        'user_profile': userProfile,
        'recent_workouts': recentWorkouts,
        'current_date': DateTime.now().toIso8601String(),
      };

      final prompt = '''
Based on the user's profile and recent workout history, generate a personalized workout recommendation.

User Profile: $userProfile
Recent Workouts: $recentWorkouts

Provide a workout recommendation that includes:
1. Workout type and focus area
2. Recommended exercises with sets and reps
3. Estimated duration
4. Difficulty level
5. Tips for success

Format the response as JSON with the following structure:
{
  "workout_type": "string",
  "focus_area": "string",
  "exercises": [{"name": "string", "sets": number, "reps": number, "rest": number}],
  "duration": number,
  "difficulty": "string",
  "tips": ["string"],
  "motivation": "string"
}
''';

      final response = await _openAIService.sendChatCompletion(
        messages: [
          {'role': 'system', 'content': 'You are a professional fitness coach creating personalized workout plans.'},
          {'role': 'user', 'content': prompt},
        ],
        temperature: 0.8,
      );

      // Parse JSON response
      final data = _parseJsonResponse(response);
      
      return CoachRecommendationModel(
        id: DateTime.now().millisecondsSinceEpoch.toString(),
        userId: userId,
        type: 'workout',
        title: 'Personalized Workout Plan',
        description: data['motivation'] ?? 'Your personalized workout recommendation',
        data: data,
        createdAt: DateTime.now(),
        priority: 4,
      );
    } catch (e) {
      throw Exception('Failed to generate workout recommendation: $e');
    }
  }

  /// Analyze workout performance
  Future<String> analyzeWorkoutPerformance({
    required Map<String, dynamic> workoutData,
    required String userGoal,
  }) async {
    try {
      return await _openAIService.analyzeWorkoutPerformance(
        workoutData: workoutData,
        userGoal: userGoal,
      );
    } catch (e) {
      throw Exception('Failed to analyze workout performance: $e');
    }
  }

  /// Generate motivational message
  Future<String> generateMotivationalMessage({
    required String userMood,
    required String workoutType,
    Map<String, dynamic>? userProgress,
  }) async {
    try {
      return await _openAIService.generateMotivationalMessage(
        userMood: userMood,
        workoutType: workoutType,
      );
    } catch (e) {
      throw Exception('Failed to generate motivational message: $e');
    }
  }

  /// Start voice interaction
  Future<void> startVoiceInteraction({
    required Function(String text) onSpeechRecognized,
    required Function(String text) onResponseReady,
  }) async {
    try {
      await _voiceService.startListening(
        onResult: (text) async {
          onSpeechRecognized(text);
          
          // Get AI response
          final response = await sendMessage(
            message: text,
            context: {'interaction_type': 'voice'},
          );
          
          // Speak response
          await _voiceService.speak(response);
          onResponseReady(response);
        },
        onError: () {
          // Handle speech recognition error
        },
      );
    } catch (e) {
      throw Exception('Failed to start voice interaction: $e');
    }
  }

  /// Stop voice interaction
  Future<void> stopVoiceInteraction() async {
    try {
      await _voiceService.stopListening();
      await _voiceService.stopSpeaking();
    } catch (e) {
      throw Exception('Failed to stop voice interaction: $e');
    }
  }

  /// Get conversation history
  Future<List<CoachMessageModel>> getConversationHistory({
    String? userId,
    int? limit,
  }) async {
    try {
      final currentUserId = userId ?? _supabaseService.currentUser?.id;
      if (currentUserId == null) throw Exception('User not authenticated');

      var query = _supabaseService.client
          .from('coach_messages')
          .select()
          .eq('user_id', currentUserId)
          .order('timestamp', ascending: false);

      if (limit != null) {
        query = query.limit(limit);
      }

      final response = await query;
      
      return (response as List)
          .map((json) => CoachMessageModel.fromJson(json))
          .toList();
    } catch (e) {
      throw Exception('Failed to get conversation history: $e');
    }
  }

  /// Save conversation
  Future<void> _saveConversation(
    String message,
    String response,
    Map<String, dynamic> context,
  ) async {
    try {
      final userId = _supabaseService.currentUser?.id;
      if (userId == null) return;

      await _supabaseService.client.from('coach_messages').insert([
        {
          'user_id': userId,
          'message': message,
          'response': response,
          'message_type': 'user',
          'timestamp': DateTime.now().toIso8601String(),
          'context': context,
          'is_processed': true,
        },
        {
          'user_id': userId,
          'message': response,
          'response': '',
          'message_type': 'coach',
          'timestamp': DateTime.now().toIso8601String(),
          'context': context,
          'is_processed': true,
        },
      ]);
    } catch (e) {
      // Log error but don't throw
      print('Failed to save conversation: $e');
    }
  }

  /// Prepare AI context
  Map<String, dynamic> _prepareAIContext(Map<String, dynamic> context) {
    return {
      'user_id': _supabaseService.currentUser?.id,
      'timestamp': DateTime.now().toIso8601String(),
      ...context,
    };
  }

  /// Parse JSON response from AI
  Map<String, dynamic> _parseJsonResponse(String response) {
    try {
      // Extract JSON from response
      final jsonStart = response.indexOf('{');
      final jsonEnd = response.lastIndexOf('}') + 1;
      
      if (jsonStart >= 0 && jsonEnd > jsonStart) {
        final jsonString = response.substring(jsonStart, jsonEnd);
        return Map<String, dynamic>.from(
          json.decode(jsonString) as Map,
        );
      }
      
      return {'error': 'Invalid JSON response'};
    } catch (e) {
      return {'error': 'Failed to parse response: $e'};
    }
  }
}
```

### 3. AI Coach Provider

Create `lib/features/ai_coach/domain/providers/ai_coach_provider.dart`:

```dart
import 'package:flutter/material.dart';
import '../../data/models/coach_message_model.dart';
import '../../data/models/coach_recommendation_model.dart';
import '../../data/repositories/ai_coach_repository.dart';

class AICoachProvider extends ChangeNotifier {
  final AICoachRepository _aiCoachRepository = AICoachRepository();
  
  List<CoachMessageModel> _conversationHistory = [];
  List<CoachRecommendationModel> _recommendations = [];
  bool _isLoading = false;
  bool _isVoiceActive = false;
  String? _error;
  String? _currentResponse;

  // Getters
  List<CoachMessageModel> get conversationHistory => _conversationHistory;
  List<CoachRecommendationModel> get recommendations => _recommendations;
  bool get isLoading => _isLoading;
  bool get isVoiceActive => _isVoiceActive;
  String? get error => _error;
  String? get currentResponse => _currentResponse;

  /// Send message to AI coach
  Future<String?> sendMessage({
    required String message,
    Map<String, dynamic>? context,
  }) async {
    try {
      _setLoading(true);
      _clearError();
      _setCurrentResponse(null);

      final response = await _aiCoachRepository.sendMessage(
        message: message,
        context: context ?? {},
      );

      _setCurrentResponse(response);
      
      // Reload conversation history
      await loadConversationHistory();
      
      return response;
    } catch (e) {
      _setError('Failed to send message: $e');
      return null;
    } finally {
      _setLoading(false);
    }
  }

  /// Start voice interaction
  Future<void> startVoiceInteraction() async {
    try {
      _setVoiceActive(true);
      _clearError();

      await _aiCoachRepository.startVoiceInteraction(
        onSpeechRecognized: (text) {
          // Handle speech recognition
          _setCurrentResponse('Listening: $text');
        },
        onResponseReady: (response) {
          _setCurrentResponse(response);
          loadConversationHistory();
        },
      );
    } catch (e) {
      _setError('Failed to start voice interaction: $e');
      _setVoiceActive(false);
    }
  }

  /// Stop voice interaction
  Future<void> stopVoiceInteraction() async {
    try {
      await _aiCoachRepository.stopVoiceInteraction();
      _setVoiceActive(false);
    } catch (e) {
      _setError('Failed to stop voice interaction: $e');
    }
  }

  /// Generate workout recommendation
  Future<CoachRecommendationModel?> generateWorkoutRecommendation({
    required Map<String, dynamic> userProfile,
    required List<Map<String, dynamic>> recentWorkouts,
  }) async {
    try {
      _setLoading(true);
      _clearError();

      final userId = _aiCoachRepository._supabaseService.currentUser?.id;
      if (userId == null) {
        _setError('User not authenticated');
        return null;
      }

      final recommendation = await _aiCoachRepository.generateWorkoutRecommendation(
        userId: userId,
        userProfile: userProfile,
        recentWorkouts: recentWorkouts,
      );

      _recommendations.insert(0, recommendation);
      notifyListeners();

      return recommendation;
    } catch (e) {
      _setError('Failed to generate recommendation: $e');
      return null;
    } finally {
      _setLoading(false);
    }
  }

  /// Analyze workout performance
  Future<String?> analyzeWorkoutPerformance({
    required Map<String, dynamic> workoutData,
    required String userGoal,
  }) async {
    try {
      _setLoading(true);
      _clearError();

      final analysis = await _aiCoachRepository.analyzeWorkoutPerformance(
        workoutData: workoutData,
        userGoal: userGoal,
      );

      _setCurrentResponse(analysis);
      return analysis;
    } catch (e) {
      _setError('Failed to analyze workout performance: $e');
      return null;
    } finally {
      _setLoading(false);
    }
  }

  /// Generate motivational message
  Future<String?> generateMotivationalMessage({
    required String userMood,
    required String workoutType,
    Map<String, dynamic>? userProgress,
  }) async {
    try {
      _setLoading(true);
      _clearError();

      final message = await _aiCoachRepository.generateMotivationalMessage(
        userMood: userMood,
        workoutType: workoutType,
      );

      _setCurrentResponse(message);
      return message;
    } catch (e) {
      _setError('Failed to generate motivational message: $e');
      return null;
    } finally {
      _setLoading(false);
    }
  }

  /// Load conversation history
  Future<void> loadConversationHistory({int? limit}) async {
    try {
      _setLoading(true);
      _clearError();

      _conversationHistory = await _aiCoachRepository.getConversationHistory(
        limit: limit,
      );
      
      notifyListeners();
    } catch (e) {
      _setError('Failed to load conversation history: $e');
    } finally {
      _setLoading(false);
    }
  }

  /// Clear conversation history
  void clearConversationHistory() {
    _conversationHistory.clear();
    notifyListeners();
  }

  /// Clear error
  void clearError() {
    _clearError();
  }

  /// Clear current response
  void clearCurrentResponse() {
    _setCurrentResponse(null);
  }

  // Private methods
  void _setLoading(bool loading) {
    _isLoading = loading;
    notifyListeners();
  }

  void _setVoiceActive(bool active) {
    _isVoiceActive = active;
    notifyListeners();
  }

  void _setError(String error) {
    _error = error;
    notifyListeners();
  }

  void _clearError() {
    _error = null;
    notifyListeners();
  }

  void _setCurrentResponse(String? response) {
    _currentResponse = response;
    notifyListeners();
  }
}
```

## Implementation Guidelines

1. **AI Integration**: Use OpenAI API for intelligent responses
2. **Voice Interaction**: Implement speech-to-text and text-to-speech
3. **Context Awareness**: Provide personalized responses based on user data
4. **Real-time Communication**: Handle real-time voice interactions
5. **Data Persistence**: Save conversation history to database
6. **Error Handling**: Graceful handling of AI service failures
7. **Performance**: Optimize for quick response times

## Next Steps

After implementing the AI coach module:

1. Create AI coach chat screen
2. Implement voice interaction UI
3. Add recommendation display screen
4. Create workout analysis screen
5. Add motivational message features
6. Implement conversation history
7. Add AI coach settings

Remember to:
- Handle AI service failures gracefully
- Implement proper voice interaction controls
- Save conversation history
- Provide personalized recommendations
- Test all AI interactions
- Optimize response times 